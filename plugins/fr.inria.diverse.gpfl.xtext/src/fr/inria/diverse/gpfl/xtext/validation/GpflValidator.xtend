/*
 * generated by Xtext 2.27.0
 */
package fr.inria.diverse.gpfl.xtext.validation

import fr.inria.diverse.gpfl.model.gpfl.Accept
import fr.inria.diverse.gpfl.model.gpfl.Automata
import fr.inria.diverse.gpfl.model.gpfl.BinaryOp
import fr.inria.diverse.gpfl.model.gpfl.BooleanLiteral
import fr.inria.diverse.gpfl.model.gpfl.Div
import fr.inria.diverse.gpfl.model.gpfl.Drop
import fr.inria.diverse.gpfl.model.gpfl.Equality
import fr.inria.diverse.gpfl.model.gpfl.GpflPackage
import fr.inria.diverse.gpfl.model.gpfl.Greater
import fr.inria.diverse.gpfl.model.gpfl.GreaterOrEqual
import fr.inria.diverse.gpfl.model.gpfl.Inequality
import fr.inria.diverse.gpfl.model.gpfl.InitSeq
import fr.inria.diverse.gpfl.model.gpfl.IntLiteral
import fr.inria.diverse.gpfl.model.gpfl.Lower
import fr.inria.diverse.gpfl.model.gpfl.LowerOrEqual
import fr.inria.diverse.gpfl.model.gpfl.Minus
import fr.inria.diverse.gpfl.model.gpfl.Mult
import fr.inria.diverse.gpfl.model.gpfl.NewInterruption
import fr.inria.diverse.gpfl.model.gpfl.Nop
import fr.inria.diverse.gpfl.model.gpfl.Plus
import fr.inria.diverse.gpfl.model.gpfl.StringLiteral
import org.eclipse.xtext.validation.Check
import fr.inria.diverse.gpfl.model.gpfl.Filter

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GpflValidator extends AbstractGpflValidator {
	
	// ------------------------ AUTOMATA ------------------------ //
	
	public static val MISSING_INIT_STATE = "missinginitstate"
	
	@Check
	def checkInitState(Automata automata) {
		if (automata.transitions.filter[t | t.from.equals(automata.initialState)].empty) {
			error("This automata can't start because there is no outgoing transitions from the initial state",
				GpflPackage.Literals.AUTOMATA__TRANSITIONS,
				MISSING_INIT_STATE
			)
		}
	}
	
	public static val EMPTY_NAME_AUTOMATA =  "emptynameautomata"
	
	@Check
	def checkEmptyNameAutomata(Automata automata) {
		if (automata.name.isEmpty) {
			error("An automata can't have an empty name",
				GpflPackage.Literals.AUTOMATA__NAME,
				EMPTY_NAME_AUTOMATA
			)
		}
	}
	
	// ------------------------ INIT SEQ ------------------------ //
	
	public static val NEG_TIME_INTERRUPT = "negtimeinterrupt"
	
	@Check
	def checkTimeInterrupt(NewInterruption interupt) {
		if (interupt.time <= 0) {
			error('An interruption must have a time superior to 0',
				GpflPackage.Literals.NEW_INTERRUPTION__TIME,
				NEG_TIME_INTERRUPT
			)
		}
	}
	
	public static val EMPTY_INTERRUPT = "emptyinterrupt"
	
	@Check
	def checkBlockInterrupt(NewInterruption interupt) {
		if (interupt.block.firstStmt instanceof Nop && interupt.block.firstStmt.next === null) {
			warning('This interuption will not execute anything',
				GpflPackage.Literals.NEW_INTERRUPTION__BLOCK,
				EMPTY_INTERRUPT
			)
		}
	}
	
	// ------------------------ FILTER ------------------------ //
	
	public static val USELESS_CMD_IN_INIT = "uselesscmdininit"
	
	@Check
	def checkCommandInInit(InitSeq init) {
		var cmd = init.block.firstStmt
		while(cmd !== null) {
			if (cmd instanceof Accept || cmd instanceof Drop || cmd instanceof Nop) {				
				warning('There is useless command in this initialization (accept, drop or nop)',
					GpflPackage.Literals.INIT_SEQ__BLOCK,
					USELESS_CMD_IN_INIT
				)
			}
			cmd = cmd.next
		} 
	}
	
	public static val FILTER_STARTS_WITH_DROP_OR_ACCEPT = "filterstartswithdroporaccept"
	
	@Check
	def checkStartsOfFilter(Filter filter) {
		if(filter.block.firstStmt instanceof Accept) {
			warning('This filter will only accept every packets',
				GpflPackage.Literals.FILTER__BLOCK,
				FILTER_STARTS_WITH_DROP_OR_ACCEPT
			)
		}
		if(filter.block.firstStmt instanceof Drop) {
			warning('This filter will only drop every packets',
				GpflPackage.Literals.FILTER__BLOCK,
				FILTER_STARTS_WITH_DROP_OR_ACCEPT
			)
		}
	}
	
	// ------------------------ EXPRESSION ------------------------ //
	
	public static val CONSTANT_COMPARISON = "constantcomparison"
	
	@Check
	def checkConstantComparison(BinaryOp exp) {
		if ((exp instanceof Inequality || exp instanceof Equality
			|| exp instanceof LowerOrEqual || exp instanceof Lower
			|| exp instanceof GreaterOrEqual || exp instanceof Greater)
			&& ((exp.left instanceof BooleanLiteral || exp.left instanceof IntLiteral || exp.left instanceof StringLiteral)
				&& (exp.right instanceof BooleanLiteral || exp.right instanceof IntLiteral || exp.right instanceof StringLiteral)
			)
		) {
			warning( 'constant condition is always false',
				GpflPackage.Literals.BINARY_OP__RIGHT,
				CONSTANT_COMPARISON
			)
		}
	}
	
	public static val WRONG_TYPE_ADDITION = "wrongtypeaddition"
	
	@Check
	def checkTypeAddition(BinaryOp exp) {
		if((exp instanceof Plus || exp instanceof Minus || exp instanceof Mult || exp instanceof Div)
			&& (exp.left instanceof BooleanLiteral || exp.right instanceof BooleanLiteral)
		) {
			error('booleans cannot be used in a calculus',
				GpflPackage.Literals.BINARY_OP__RIGHT,
				WRONG_TYPE_ADDITION
			)
		}
	}
	
	
}